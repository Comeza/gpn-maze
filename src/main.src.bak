use std::collections::{HashMap, HashSet, VecDeque};
use std::io::{BufRead, BufReader, Write};
use std::net::TcpStream;
use std::str::FromStr;

#[derive(Debug)]
enum GpnError {
    Soft(String),
    Unknown(String),
    ParseError(String),
}

#[derive(Hash, Eq, PartialEq, Copy, Clone)]
struct Position {
    x: i32,
    y: i32,
}

impl std::fmt::Debug for Position {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

impl Position {
    fn parse(coords: &[&str]) -> Result<Self, std::num::ParseIntError> {
        Ok(Position {
            x: coords[0].parse()?,
            y: coords[1].parse()?,
        })
    }

    fn new(x: i32, y: i32) -> Self {
        Self { x, y }
    }

    fn add(&self, d: &Direction) -> Self {
        let x = self.x;
        let y = self.y;
        match d {
            Direction::Up => Self { x, y: y - 1 },
            Direction::Right => Self { x: x + 1, y },
            Direction::Down => Self { x, y: y + 1 },
            Direction::Left => Self { x: x - 1, y },
        }
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
enum Direction {
    Up,
    Right,
    Down,
    Left,
}

impl std::fmt::Display for Direction {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Up => "up",
                Self::Right => "right",
                Self::Down => "down",
                Self::Left => "left",
            }
        )
    }
}

impl Direction {
    fn parse(args: [&str; 4]) -> Vec<Self> {
        let dic = [
            Direction::Up,
            Direction::Right,
            Direction::Down,
            Direction::Left,
        ];
        let mut out = Vec::new();
        for (i, arg) in args.iter().enumerate() {
            if arg == &"0" {
                out.push(dic[i]);
            }
        }

        return out;
    }
}

#[derive(Debug)]
enum Proto {
    Join {
        name: String,
        password: String,
    },
    Goal {
        pos: Position,
    },
    Pos {
        pos: Position,
        space: Vec<Direction>,
    },
    Move {
        direction: Direction,
    },
    Chat {
        message: String,
    },
    Motd {
        message: String,
    },
    Win {
        wins: i32,
        loses: i32,
    },
    Lose {
        wins: i32,
        loses: i32,
    },
}

impl FromStr for Proto {
    type Err = GpnError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let args = s.split('|').collect::<Vec<_>>();
        if args.is_empty() {
            return Err(GpnError::Soft(String::from("No args found")));
        }

        return match (args[0], args.len()) {
            ("chat", 2) => Ok(Proto::Chat {
                message: args[1].to_string(),
            }),
            ("motd", 2) => Ok(Proto::Motd {
                message: args[1].to_string(),
            }),
            ("goal", 3) => Ok(Proto::Goal {
                pos: Position::parse(&args[1..])
                    .map_err(|e| GpnError::ParseError(format!("{e}")))?,
            }),
            ("pos", 7) => Ok(Proto::Pos {
                pos: Position::parse(&[args[1], args[2]])
                    .map_err(|e| GpnError::ParseError(format!("{e}")))?,
                space: Direction::parse([args[3], args[4], args[5], args[6]]),
            }),
            ("win", 3) => Ok(Proto::Win {
                wins: args[1]
                    .parse()
                    .map_err(|e| GpnError::ParseError(format!("{e}")))?,
                loses: args[2]
                    .parse()
                    .map_err(|e| GpnError::ParseError(format!("{e}")))?,
            }),
            ("lose", 3) => Ok(Proto::Lose {
                wins: args[1]
                    .parse()
                    .map_err(|e| GpnError::ParseError(format!("{e}")))?,
                loses: args[2]
                    .parse()
                    .map_err(|e| GpnError::ParseError(format!("{e}")))?,
            }),
            ("error", _) => Err(GpnError::Soft(format!("Received Error : {}", s))),
            _ => Err(GpnError::Unknown(format!("Unknown Proto message : {}", s))),
        };
    }
}

struct AdjList(HashMap<Position, HashSet<Direction>>);

impl AdjList {
    fn new() -> Self {
        AdjList(HashMap::new())
    }

    fn reset(&mut self) {
        self.0 = Self::new().0;
    }

    fn find_next(&self, pos: &Position) -> Position {
        for (k, val) in &self.0 {
            if let Some(p) = val.iter().map(|d| k.add(d)).find(|p| !self.contains_key(p)) {
                return p;
            }
        }
        panic!("No next positon found -- no solution")
    }

    fn get_route(
        &self,
        a: &Position,
        b: &Position,
        last: &Position,
    ) -> Option<VecDeque<Direction>> {
        for dir in &self[a] {
            let pos = a.add(dir);

            if pos == *b {
                return Some(VecDeque::from([*dir]))
            }

            if !self.contains_key(&pos) || pos == *last {
                continue;
            }

            let routes = self.get_route(&pos, b, a);
            if let Some(mut routes) = routes {
                routes.push_front(*dir);
                return Some(routes);
            }
        }

        None
    }
}

impl std::ops::Deref for AdjList {
    type Target = HashMap<Position, HashSet<Direction>>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::ops::DerefMut for AdjList {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

fn main() -> std::io::Result<()> {
    println!("POS: {:?}", Position::new(0, 0).add(&Direction::Right));
    let mut stream = BufReader::new(TcpStream::connect("94.45.253.163:4000")?);
    let mut out = String::new();
    stream.read_line(&mut out)?;

    println!("CONNECT: {}", out);
    writeln!(stream.get_mut(), "join|Staubichsauger|unendlich")?;

    let mut adj_list = AdjList::new();
    let mut route: Option<VecDeque<Direction>> = None;

    loop {
        let mut line = String::new();
        if stream.read_line(&mut line)? == 0 {
            break;
        }
        let line = line.replace('\n', "");

        match Proto::from_str(&line) {
            Ok(p) => {
                // println!(" :: {:?}", p);

                match p {
                    Proto::Pos { pos, space } if !space.is_empty() => {
                        println!(" :: CURR: {:?}", &pos);
                        if route == None {
                            adj_list
                                .entry(pos)
                                .or_insert(HashSet::from_iter(space.clone().into_iter()));
                            let next = adj_list.find_next(&pos);
                            println!("next : {next:?}");
                            let r = adj_list.get_route(&pos, &next, &pos);
                            println!("new route : {r:?}");
                            println!("visited: {:?}", adj_list.keys().collect::<Vec<_>>());
                            route = r;
                        }

                        if let Some(r) = &mut route {
                            let dir = r.pop_front().unwrap();
                            if r.is_empty() {
                                route = None
                            }
                            writeln!(stream.get_mut(), "move|{}", dir)?;
                        } else {
                            eprintln!("NO  ROUTE");
                        }

                        println!("");
                    }
                    Proto::Win { .. } | Proto::Lose { .. } => {
                        println!(" :: RESET");
                        route = None;
                        adj_list.reset();
                    }
                    _ => {}
                }
            }
            Err(e) => eprintln!(" !! <{line}> {e:?}"),
        }
    }
    Ok(())
}
